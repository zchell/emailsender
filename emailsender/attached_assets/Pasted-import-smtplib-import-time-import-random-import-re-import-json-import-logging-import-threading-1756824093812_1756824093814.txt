import smtplib
import time
import random
import re
import json
import logging
import threading
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders
from dataclasses import dataclass
from typing import List, Dict, Optional, Tuple
from datetime import datetime, timedelta
import dns.resolver
import socket
from concurrent.futures import ThreadPoolExecutor, as_completed

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class SMTPConfig:
    """SMTP server configuration"""
    host: str
    port: int
    username: str
    password: str
    use_tls: bool = True
    max_emails_per_hour: int = 100
    current_count: int = 0
    last_reset: Optional[datetime] = None
    is_active: bool = True
    reputation_score: float = 100.0

@dataclass
class EmailTemplate:
    """Email template structure"""
    subject: str
    html_body: str
    text_body: str
    from_name: str
    reply_to: Optional[str] = None

class AdvancedMailer:
    """Advanced email sender with anti-spam and SMTP rotation"""
    
    def __init__(self):
        self.smtp_configs: List[SMTPConfig] = []
        self.current_smtp_index = 0
        self.sent_emails = []
        self.failed_emails = []
        self.email_queue = []
        self.sending_stats = {
            'total_sent': 0,
            'total_failed': 0,
            'total_bounced': 0,
            'delivery_rate': 0.0
        }
        self.lock = threading.Lock()
        
    def add_smtp_server(self, host: str, port: int, username: str, password: str, 
                       use_tls: bool = True, max_emails_per_hour: int = 100):
        """Add SMTP server configuration"""
        config = SMTPConfig(
            host=host,
            port=port,
            username=username,
            password=password,
            use_tls=use_tls,
            max_emails_per_hour=max_emails_per_hour,
            last_reset=datetime.now()
        )
        self.smtp_configs.append(config)
        logger.info(f"Added SMTP server: {host}:{port}")
    
    def validate_email(self, email: str) -> bool:
        """Validate email address format and domain"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        if not re.match(pattern, email):
            return False
        
        try:
            domain = email.split('@')[1]
            mx_records = dns.resolver.resolve(domain, 'MX')
            return len(mx_records) > 0
        except:
            return False
    
    def check_smtp_limits(self, smtp_config: SMTPConfig) -> bool:
        """Check if SMTP server is within rate limits"""
        now = datetime.now()
        if smtp_config.last_reset and (now - smtp_config.last_reset).total_seconds() >= 3600:
            smtp_config.current_count = 0
            smtp_config.last_reset = now
        
        return smtp_config.current_count < smtp_config.max_emails_per_hour
    
    def get_next_smtp(self) -> Optional[SMTPConfig]:
        """Get next available SMTP server with rotation"""
        if not self.smtp_configs:
            return None
        
        attempts = 0
        while attempts < len(self.smtp_configs):
            config = self.smtp_configs[self.current_smtp_index]
            self.current_smtp_index = (self.current_smtp_index + 1) % len(self.smtp_configs)
            
            if config.is_active and self.check_smtp_limits(config):
                return config
            
            attempts += 1
        
        logger.warning("No available SMTP servers within limits")
        return None
    
    def humanize_content(self, content: str) -> str:
        """Apply anti-spam content modifications"""
        # Add random invisible characters
        content = content.replace(' ', random.choice([' ', '\u00A0', '\u2009']))
        
        # Break up common spam words
        spam_words = {
            'free': ['f.r.e.e', 'fr33', 'f-r-e-e'],
            'money': ['m0ney', 'm.o.n.e.y', 'mon3y'],
            'urgent': ['urg3nt', 'u.r.g.e.n.t', 'urg-ent'],
            'limited': ['l1mited', 'lim.ited', 'limit3d'],
            'offer': ['0ffer', 'of.fer', 'off3r'],
            'click here': ['click h3re', 'cl1ck here', 'click.here']
        }
        
        for word, variations in spam_words.items():
            if word.lower() in content.lower():
                replacement = random.choice(variations)
                content = re.sub(re.escape(word), replacement, content, flags=re.IGNORECASE)
        
        return content
    
    def create_optimized_message(self, to_email: str, template: EmailTemplate, 
                                personalization: Optional[Dict[str, str]] = None) -> MIMEMultipart:
        """Create optimized email message"""
        msg = MIMEMultipart('alternative')
        
        # Apply personalization
        subject = template.subject
        html_body = template.html_body
        text_body = template.text_body
        
        if personalization:
            for key, value in personalization.items():
                subject = subject.replace(f'{{{key}}}', value)
                html_body = html_body.replace(f'{{{key}}}', value)
                text_body = text_body.replace(f'{{{key}}}', value)
        
        # Humanize content
        subject = self.humanize_content(subject)
        html_body = self.humanize_content(html_body)
        text_body = self.humanize_content(text_body)
        
        # Set headers
        msg['To'] = to_email
        msg['Subject'] = subject
        msg['From'] = template.from_name
        msg['Reply-To'] = template.reply_to or template.from_name
        
        # Add anti-spam headers
        msg['X-Mailer'] = random.choice(['Outlook 16.0', 'Thunderbird 91.0', 'Apple Mail 14.0'])
        msg['X-Priority'] = '3'
        msg['X-MSMail-Priority'] = 'Normal'
        msg['Importance'] = 'Normal'
        
        # Add message ID for better deliverability
        domain = template.from_name.split('@')[1] if '@' in template.from_name else 'localhost'
        msg['Message-ID'] = f"<{int(time.time())}.{random.randint(1000, 9999)}@{domain}>"
        
        # Add tracking pixel (optional)
        tracking_pixel = f'<img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" width="1" height="1" style="display:none;" alt="" />'
        html_body += tracking_pixel
        
        # Attach text and HTML parts
        text_part = MIMEText(text_body, 'plain', 'utf-8')
        html_part = MIMEText(html_body, 'html', 'utf-8')
        
        msg.attach(text_part)
        msg.attach(html_part)
        
        return msg
    
    def send_single_email(self, to_email: str, template: EmailTemplate, 
                         personalization: Optional[Dict[str, str]] = None, 
                         retry_count: int = 3) -> Tuple[bool, str]:
        """Send single email with retry mechanism"""
        if not self.validate_email(to_email):
            return False, "Invalid email address"
        
        for attempt in range(retry_count):
            smtp_config = self.get_next_smtp()
            if not smtp_config:
                time.sleep(60)  # Wait 1 minute before retry
                continue
            
            try:
                # Create message
                msg = self.create_optimized_message(to_email, template, personalization)
                
                # Connect to SMTP server
                if smtp_config.use_tls:
                    server = smtplib.SMTP(smtp_config.host, smtp_config.port)
                    server.starttls()
                else:
                    server = smtplib.SMTP_SSL(smtp_config.host, smtp_config.port)
                
                server.login(smtp_config.username, smtp_config.password)
                
                # Send email
                text = msg.as_string()
                server.sendmail(msg['From'], to_email, text)
                server.quit()
                
                # Update stats
                with self.lock:
                    smtp_config.current_count += 1
                    self.sending_stats['total_sent'] += 1
                    smtp_config.reputation_score = min(100.0, smtp_config.reputation_score + 0.1)
                
                logger.info(f"Email sent successfully to {to_email} via {smtp_config.host}")
                return True, "Email sent successfully"
                
            except smtplib.SMTPRecipientsRefused:
                logger.error(f"Email rejected by recipient server: {to_email}")
                return False, "Email rejected by recipient"
            
            except smtplib.SMTPAuthenticationError:
                logger.error(f"SMTP authentication failed for {smtp_config.host}")
                smtp_config.is_active = False
                smtp_config.reputation_score *= 0.8
                continue
                
            except Exception as e:
                logger.error(f"Failed to send email to {to_email} via {smtp_config.host}: {str(e)}")
                smtp_config.reputation_score *= 0.9
                
                if attempt == retry_count - 1:
                    with self.lock:
                        self.sending_stats['total_failed'] += 1
                    return False, str(e)
                
                time.sleep(random.uniform(1, 5))  # Random delay between retries
        
        return False, "All retry attempts failed"
    
    def send_bulk_emails(self, email_list: List[str], template: EmailTemplate, 
                        personalization_data: Optional[Dict[str, Dict[str, str]]] = None,
                        max_workers: int = 5, delay_between_emails: float = 1.0) -> Dict:
        """Send bulk emails with threading and rate limiting"""
        results = {
            'successful': [],
            'failed': [],
            'total_processed': 0
        }
        
        def send_with_delay(email):
            time.sleep(random.uniform(0.5, delay_between_emails))
            personalization = personalization_data.get(email, {}) if personalization_data else {}
            success, message = self.send_single_email(email, template, personalization)
            return email, success, message
        
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            future_to_email = {
                executor.submit(send_with_delay, email): email 
                for email in email_list
            }
            
            for future in as_completed(future_to_email):
                email, success, message = future.result()
                results['total_processed'] += 1
                
                if success:
                    results['successful'].append(email)
                else:
                    results['failed'].append({'email': email, 'error': message})
                
                # Progress logging
                if results['total_processed'] % 10 == 0:
                    success_rate = len(results['successful']) / results['total_processed'] * 100
                    logger.info(f"Processed {results['total_processed']}/{len(email_list)} emails. Success rate: {success_rate:.1f}%")
        
        # Update global stats
        self.sending_stats['delivery_rate'] = len(results['successful']) / len(email_list) * 100 if email_list else 0
        
        return results
    
    def get_stats(self) -> Dict:
        """Get sending statistics"""
        return {
            **self.sending_stats,
            'smtp_servers': len(self.smtp_configs),
            'active_servers': sum(1 for config in self.smtp_configs if config.is_active),
            'server_status': [
                {
                    'host': config.host,
                    'active': config.is_active,
                    'emails_sent_this_hour': config.current_count,
                    'reputation_score': config.reputation_score
                }
                for config in self.smtp_configs
            ]
        }
    
    def save_config(self, filename: str):
        """Save SMTP configurations to file"""
        config_data = []
        for config in self.smtp_configs:
            config_data.append({
                'host': config.host,
                'port': config.port,
                'username': config.username,
                'password': config.password,
                'use_tls': config.use_tls,
                'max_emails_per_hour': config.max_emails_per_hour
            })
        
        with open(filename, 'w') as f:
            json.dump(config_data, f, indent=2)
    
    def load_config(self, filename: str):
        """Load SMTP configurations from file"""
        try:
            with open(filename, 'r') as f:
                config_data = json.load(f)
            
            for config in config_data:
                self.add_smtp_server(**config)
                
            logger.info(f"Loaded {len(config_data)} SMTP configurations")
        except FileNotFoundError:
            logger.warning(f"Config file {filename} not found")
    
    def load_smtp_from_txt(self, filename: str = "smtp.txt"):
        """Load SMTP configurations from text file"""
        try:
            with open(filename, 'r') as f:
                lines = f.readlines()
            
            loaded_count = 0
            for line in lines:
                line = line.strip()
                # Skip comments and empty lines
                if not line or line.startswith('#'):
                    continue
                
                try:
                    parts = line.split(':')
                    if len(parts) >= 5:
                        host = parts[0]
                        port = int(parts[1])
                        username = parts[2]
                        password = parts[3]
                        use_tls = parts[4].lower() == 'true'
                        max_emails = int(parts[5]) if len(parts) > 5 else 100
                        
                        self.add_smtp_server(
                            host=host,
                            port=port,
                            username=username,
                            password=password,
                            use_tls=use_tls,
                            max_emails_per_hour=max_emails
                        )
                        loaded_count += 1
                except (ValueError, IndexError) as e:
                    logger.warning(f"Invalid SMTP config line: {line} - {str(e)}")
                    continue
                    
            logger.info(f"Loaded {loaded_count} SMTP configurations from {filename}")
            
        except FileNotFoundError:
            logger.warning(f"SMTP config file {filename} not found")

# Example usage
if __name__ == "__main__":
    # Initialize mailer
    mailer = AdvancedMailer()
    
    # Add SMTP servers (replace with your actual SMTP settings)
    mailer.add_smtp_server(
        host="smtp.gmail.com",
        port=587,
        username="your-email@gmail.com",
        password="your-app-password",
        max_emails_per_hour=50
    )
    
    mailer.add_smtp_server(
        host="smtp.sendgrid.net",
        port=587,
        username="apikey",
        password="your-sendgrid-api-key",
        max_emails_per_hour=100
    )
    
    # Create email template
    template = EmailTemplate(
        subject="Important Update - {name}",
        html_body="""
        <html>
        <body>
            <h2>Hello {name},</h2>
            <p>We have an important update for you regarding your account.</p>
            <p>Please review the details below:</p>
            <ul>
                <li>Account Status: Active</li>
                <li>Last Login: {last_login}</li>
                <li>Security Level: Enhanced</li>
            </ul>
            <p>If you have any questions, please don't hesitate to contact us.</p>
            <p>Best regards,<br>The Team</p>
        </body>
        </html>
        """,
        text_body="""
        Hello {name},
        
        We have an important update for you regarding your account.
        
        Please review the details below:
        - Account Status: Active
        - Last Login: {last_login}
        - Security Level: Enhanced
        
        If you have any questions, please don't hesitate to contact us.
        
        Best regards,
        The Team
        """,
        from_name="Team <noreply@yourcompany.com>",
        reply_to="support@yourcompany.com"
    )
    
    # Email list and personalization data
    email_list = [
        "user1@example.com",
        "user2@example.com",
        "user3@example.com"
    ]
    
    personalization_data = {
        "user1@example.com": {"name": "John", "last_login": "2024-01-15"},
        "user2@example.com": {"name": "Jane", "last_login": "2024-01-14"},
        "user3@example.com": {"name": "Bob", "last_login": "2024-01-13"}
    }
    
    # Send bulk emails
    print("Starting bulk email campaign...")
    results = mailer.send_bulk_emails(
        email_list=email_list,
        template=template,
        personalization_data=personalization_data,
        max_workers=3,
        delay_between_emails=2.0
    )
    
    # Print results
    print(f"\nCampaign Results:")
    print(f"Total Processed: {results['total_processed']}")
    print(f"Successful: {len(results['successful'])}")
    print(f"Failed: {len(results['failed'])}")
    
    # Print statistics
    stats = mailer.get_stats()
    print(f"\nOverall Statistics:")
    print(f"Delivery Rate: {stats['delivery_rate']:.1f}%")
    print(f"Active SMTP Servers: {stats['active_servers']}/{stats['smtp_servers']}")